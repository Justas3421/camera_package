// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v22.7.4), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#import "Messages.h"

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#if !__has_feature(objc_arc)
#error File requires ARC to be enabled.
#endif

static NSArray<id> *wrapResult(id result, FlutterError *error) {
  if (error) {
    return @[
      error.code ?: [NSNull null], error.message ?: [NSNull null], error.details ?: [NSNull null]
    ];
  }
  return @[ result ?: [NSNull null] ];
}

static FlutterError *createConnectionError(NSString *channelName) {
  return [FlutterError errorWithCode:@"channel-error" message:[NSString stringWithFormat:@"%@/%@/%@", @"Unable to establish connection on channel: '", channelName, @"'."] details:@""];
}

static id GetNullableObjectAtIndex(NSArray<id> *array, NSInteger key) {
  id result = array[key];
  return (result == [NSNull null]) ? nil : result;
}

/// Pigeon equivalent of [CameraLensDirection].
@implementation PlatformCameraLensDirectionBox
- (instancetype)initWithValue:(PlatformCameraLensDirection)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Pigeon equivalent of [DeviceOrientation].
@implementation PlatformDeviceOrientationBox
- (instancetype)initWithValue:(PlatformDeviceOrientation)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Pigeon equivalent of [ExposureMode].
@implementation PlatformExposureModeBox
- (instancetype)initWithValue:(PlatformExposureMode)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Pigeon equivalent of [FocusMode].
@implementation PlatformFocusModeBox
- (instancetype)initWithValue:(PlatformFocusMode)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Pigeon equivalent of [ResolutionPreset].
@implementation PlatformResolutionPresetBox
- (instancetype)initWithValue:(PlatformResolutionPreset)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Pigeon equivalent of [ImageFormatGroup].
@implementation PlatformImageFormatGroupBox
- (instancetype)initWithValue:(PlatformImageFormatGroup)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Pigeon equivalent of [FlashMode].
@implementation PlatformFlashModeBox
- (instancetype)initWithValue:(PlatformFlashMode)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

@interface PlatformCameraDescription ()
+ (PlatformCameraDescription *)fromList:(NSArray<id> *)list;
+ (nullable PlatformCameraDescription *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface PlatformCameraState ()
+ (PlatformCameraState *)fromList:(NSArray<id> *)list;
+ (nullable PlatformCameraState *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface PlatformSize ()
+ (PlatformSize *)fromList:(NSArray<id> *)list;
+ (nullable PlatformSize *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface PlatformPoint ()
+ (PlatformPoint *)fromList:(NSArray<id> *)list;
+ (nullable PlatformPoint *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@interface PlatformMediaSettings ()
+ (PlatformMediaSettings *)fromList:(NSArray<id> *)list;
+ (nullable PlatformMediaSettings *)nullableFromList:(NSArray<id> *)list;
- (NSArray<id> *)toList;
@end

@implementation PlatformCameraDescription
+ (instancetype)makeWithName:(NSString *)name
    lensDirection:(PlatformCameraLensDirection)lensDirection
    sensorOrientation:(NSInteger )sensorOrientation {
  PlatformCameraDescription* pigeonResult = [[PlatformCameraDescription alloc] init];
  pigeonResult.name = name;
  pigeonResult.lensDirection = lensDirection;
  pigeonResult.sensorOrientation = sensorOrientation;
  return pigeonResult;
}
+ (PlatformCameraDescription *)fromList:(NSArray<id> *)list {
  PlatformCameraDescription *pigeonResult = [[PlatformCameraDescription alloc] init];
  pigeonResult.name = GetNullableObjectAtIndex(list, 0);
  PlatformCameraLensDirectionBox *boxedPlatformCameraLensDirection = GetNullableObjectAtIndex(list, 1);
  pigeonResult.lensDirection = boxedPlatformCameraLensDirection.value;
  pigeonResult.sensorOrientation = [GetNullableObjectAtIndex(list, 2) integerValue];
  return pigeonResult;
}
+ (nullable PlatformCameraDescription *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [PlatformCameraDescription fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.name ?: [NSNull null],
    [[PlatformCameraLensDirectionBox alloc] initWithValue:self.lensDirection],
    @(self.sensorOrientation),
  ];
}
@end

@implementation PlatformCameraState
+ (instancetype)makeWithPreviewSize:(PlatformSize *)previewSize
    exposureMode:(PlatformExposureMode)exposureMode
    focusMode:(PlatformFocusMode)focusMode
    exposurePointSupported:(BOOL )exposurePointSupported
    focusPointSupported:(BOOL )focusPointSupported {
  PlatformCameraState* pigeonResult = [[PlatformCameraState alloc] init];
  pigeonResult.previewSize = previewSize;
  pigeonResult.exposureMode = exposureMode;
  pigeonResult.focusMode = focusMode;
  pigeonResult.exposurePointSupported = exposurePointSupported;
  pigeonResult.focusPointSupported = focusPointSupported;
  return pigeonResult;
}
+ (PlatformCameraState *)fromList:(NSArray<id> *)list {
  PlatformCameraState *pigeonResult = [[PlatformCameraState alloc] init];
  pigeonResult.previewSize = GetNullableObjectAtIndex(list, 0);
  PlatformExposureModeBox *boxedPlatformExposureMode = GetNullableObjectAtIndex(list, 1);
  pigeonResult.exposureMode = boxedPlatformExposureMode.value;
  PlatformFocusModeBox *boxedPlatformFocusMode = GetNullableObjectAtIndex(list, 2);
  pigeonResult.focusMode = boxedPlatformFocusMode.value;
  pigeonResult.exposurePointSupported = [GetNullableObjectAtIndex(list, 3) boolValue];
  pigeonResult.focusPointSupported = [GetNullableObjectAtIndex(list, 4) boolValue];
  return pigeonResult;
}
+ (nullable PlatformCameraState *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [PlatformCameraState fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    self.previewSize ?: [NSNull null],
    [[PlatformExposureModeBox alloc] initWithValue:self.exposureMode],
    [[PlatformFocusModeBox alloc] initWithValue:self.focusMode],
    @(self.exposurePointSupported),
    @(self.focusPointSupported),
  ];
}
@end

@implementation PlatformSize
+ (instancetype)makeWithWidth:(double )width
    height:(double )height {
  PlatformSize* pigeonResult = [[PlatformSize alloc] init];
  pigeonResult.width = width;
  pigeonResult.height = height;
  return pigeonResult;
}
+ (PlatformSize *)fromList:(NSArray<id> *)list {
  PlatformSize *pigeonResult = [[PlatformSize alloc] init];
  pigeonResult.width = [GetNullableObjectAtIndex(list, 0) doubleValue];
  pigeonResult.height = [GetNullableObjectAtIndex(list, 1) doubleValue];
  return pigeonResult;
}
+ (nullable PlatformSize *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [PlatformSize fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    @(self.width),
    @(self.height),
  ];
}
@end

@implementation PlatformPoint
+ (instancetype)makeWithX:(double )x
    y:(double )y {
  PlatformPoint* pigeonResult = [[PlatformPoint alloc] init];
  pigeonResult.x = x;
  pigeonResult.y = y;
  return pigeonResult;
}
+ (PlatformPoint *)fromList:(NSArray<id> *)list {
  PlatformPoint *pigeonResult = [[PlatformPoint alloc] init];
  pigeonResult.x = [GetNullableObjectAtIndex(list, 0) doubleValue];
  pigeonResult.y = [GetNullableObjectAtIndex(list, 1) doubleValue];
  return pigeonResult;
}
+ (nullable PlatformPoint *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [PlatformPoint fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    @(self.x),
    @(self.y),
  ];
}
@end

@implementation PlatformMediaSettings
+ (instancetype)makeWithResolutionPreset:(PlatformResolutionPreset)resolutionPreset
    fps:(nullable NSNumber *)fps
    videoBitrate:(nullable NSNumber *)videoBitrate
    audioBitrate:(nullable NSNumber *)audioBitrate
    enableAudio:(BOOL )enableAudio {
  PlatformMediaSettings* pigeonResult = [[PlatformMediaSettings alloc] init];
  pigeonResult.resolutionPreset = resolutionPreset;
  pigeonResult.fps = fps;
  pigeonResult.videoBitrate = videoBitrate;
  pigeonResult.audioBitrate = audioBitrate;
  pigeonResult.enableAudio = enableAudio;
  return pigeonResult;
}
+ (PlatformMediaSettings *)fromList:(NSArray<id> *)list {
  PlatformMediaSettings *pigeonResult = [[PlatformMediaSettings alloc] init];
  PlatformResolutionPresetBox *boxedPlatformResolutionPreset = GetNullableObjectAtIndex(list, 0);
  pigeonResult.resolutionPreset = boxedPlatformResolutionPreset.value;
  pigeonResult.fps = GetNullableObjectAtIndex(list, 1);
  pigeonResult.videoBitrate = GetNullableObjectAtIndex(list, 2);
  pigeonResult.audioBitrate = GetNullableObjectAtIndex(list, 3);
  pigeonResult.enableAudio = [GetNullableObjectAtIndex(list, 4) boolValue];
  return pigeonResult;
}
+ (nullable PlatformMediaSettings *)nullableFromList:(NSArray<id> *)list {
  return (list) ? [PlatformMediaSettings fromList:list] : nil;
}
- (NSArray<id> *)toList {
  return @[
    [[PlatformResolutionPresetBox alloc] initWithValue:self.resolutionPreset],
    self.fps ?: [NSNull null],
    self.videoBitrate ?: [NSNull null],
    self.audioBitrate ?: [NSNull null],
    @(self.enableAudio),
  ];
}
@end

@interface nullMessagesPigeonCodecReader : FlutterStandardReader
@end
@implementation nullMessagesPigeonCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 129: {
      NSNumber *enumAsNumber = [self readValue];
      return enumAsNumber == nil ? nil : [[PlatformCameraLensDirectionBox alloc] initWithValue:[enumAsNumber integerValue]];
    }
    case 130: {
      NSNumber *enumAsNumber = [self readValue];
      return enumAsNumber == nil ? nil : [[PlatformDeviceOrientationBox alloc] initWithValue:[enumAsNumber integerValue]];
    }
    case 131: {
      NSNumber *enumAsNumber = [self readValue];
      return enumAsNumber == nil ? nil : [[PlatformExposureModeBox alloc] initWithValue:[enumAsNumber integerValue]];
    }
    case 132: {
      NSNumber *enumAsNumber = [self readValue];
      return enumAsNumber == nil ? nil : [[PlatformFocusModeBox alloc] initWithValue:[enumAsNumber integerValue]];
    }
    case 133: {
      NSNumber *enumAsNumber = [self readValue];
      return enumAsNumber == nil ? nil : [[PlatformResolutionPresetBox alloc] initWithValue:[enumAsNumber integerValue]];
    }
    case 134: {
      NSNumber *enumAsNumber = [self readValue];
      return enumAsNumber == nil ? nil : [[PlatformImageFormatGroupBox alloc] initWithValue:[enumAsNumber integerValue]];
    }
    case 135: {
      NSNumber *enumAsNumber = [self readValue];
      return enumAsNumber == nil ? nil : [[PlatformFlashModeBox alloc] initWithValue:[enumAsNumber integerValue]];
    }
    case 136: 
      return [PlatformCameraDescription fromList:[self readValue]];
    case 137: 
      return [PlatformCameraState fromList:[self readValue]];
    case 138: 
      return [PlatformSize fromList:[self readValue]];
    case 139: 
      return [PlatformPoint fromList:[self readValue]];
    case 140: 
      return [PlatformMediaSettings fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface nullMessagesPigeonCodecWriter : FlutterStandardWriter
@end
@implementation nullMessagesPigeonCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[PlatformCameraLensDirectionBox class]]) {
    PlatformCameraLensDirectionBox *box = (PlatformCameraLensDirectionBox *)value;
    [self writeByte:129];
    [self writeValue:(value == nil ? [NSNull null] : [NSNumber numberWithInteger:box.value])];
  } else if ([value isKindOfClass:[PlatformDeviceOrientationBox class]]) {
    PlatformDeviceOrientationBox *box = (PlatformDeviceOrientationBox *)value;
    [self writeByte:130];
    [self writeValue:(value == nil ? [NSNull null] : [NSNumber numberWithInteger:box.value])];
  } else if ([value isKindOfClass:[PlatformExposureModeBox class]]) {
    PlatformExposureModeBox *box = (PlatformExposureModeBox *)value;
    [self writeByte:131];
    [self writeValue:(value == nil ? [NSNull null] : [NSNumber numberWithInteger:box.value])];
  } else if ([value isKindOfClass:[PlatformFocusModeBox class]]) {
    PlatformFocusModeBox *box = (PlatformFocusModeBox *)value;
    [self writeByte:132];
    [self writeValue:(value == nil ? [NSNull null] : [NSNumber numberWithInteger:box.value])];
  } else if ([value isKindOfClass:[PlatformResolutionPresetBox class]]) {
    PlatformResolutionPresetBox *box = (PlatformResolutionPresetBox *)value;
    [self writeByte:133];
    [self writeValue:(value == nil ? [NSNull null] : [NSNumber numberWithInteger:box.value])];
  } else if ([value isKindOfClass:[PlatformImageFormatGroupBox class]]) {
    PlatformImageFormatGroupBox *box = (PlatformImageFormatGroupBox *)value;
    [self writeByte:134];
    [self writeValue:(value == nil ? [NSNull null] : [NSNumber numberWithInteger:box.value])];
  } else if ([value isKindOfClass:[PlatformFlashModeBox class]]) {
    PlatformFlashModeBox *box = (PlatformFlashModeBox *)value;
    [self writeByte:135];
    [self writeValue:(value == nil ? [NSNull null] : [NSNumber numberWithInteger:box.value])];
  } else if ([value isKindOfClass:[PlatformCameraDescription class]]) {
    [self writeByte:136];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PlatformCameraState class]]) {
    [self writeByte:137];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PlatformSize class]]) {
    [self writeByte:138];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PlatformPoint class]]) {
    [self writeByte:139];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PlatformMediaSettings class]]) {
    [self writeByte:140];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface nullMessagesPigeonCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation nullMessagesPigeonCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[nullMessagesPigeonCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[nullMessagesPigeonCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *nullGetMessagesCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    nullMessagesPigeonCodecReaderWriter *readerWriter = [[nullMessagesPigeonCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}
void SetUpCameraApi(id<FlutterBinaryMessenger> binaryMessenger, NSObject<CameraApi> *api) {
  SetUpCameraApiWithSuffix(binaryMessenger, api, @"");
}

void SetUpCameraApiWithSuffix(id<FlutterBinaryMessenger> binaryMessenger, NSObject<CameraApi> *api, NSString *messageChannelSuffix) {
  messageChannelSuffix = messageChannelSuffix.length > 0 ? [NSString stringWithFormat: @".%@", messageChannelSuffix] : @"";
  /// Returns the list of available cameras.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.getAvailableCameras", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getAvailableCamerasWithError:)], @"CameraApi api (%@) doesn't respond to @selector(getAvailableCamerasWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSArray<PlatformCameraDescription *> *output = [api getAvailableCamerasWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Creates a new camera with the given name and settings and returns its ID.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.create", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(createCameraName:mediaSettings:completion:)], @"CameraApi api (%@) doesn't respond to @selector(createCameraName:mediaSettings:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_cameraName = GetNullableObjectAtIndex(args, 0);
        PlatformMediaSettings *arg_mediaSettings = GetNullableObjectAtIndex(args, 1);
        [api createCameraName:arg_cameraName mediaSettings:arg_mediaSettings completion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Initializes the camera with the given ID for the given image format.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.initialize", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(initializeImageFormat:error:)], @"CameraApi api (%@) doesn't respond to @selector(initializeImageFormat:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        PlatformImageFormatGroupBox *boxedPlatformImageFormatGroup = GetNullableObjectAtIndex(args, 0);
        PlatformImageFormatGroup arg_imageFormat = boxedPlatformImageFormatGroup.value;
        FlutterError *error;
        [api initializeImageFormat:arg_imageFormat error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Disposes of the camera with the given ID.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.dispose", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(disposeWithError:)], @"CameraApi api (%@) doesn't respond to @selector(disposeWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api disposeWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Locks the camera with the given ID to the given orientation.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.lockCaptureOrientation", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(lockCaptureOrientationOrientation:error:)], @"CameraApi api (%@) doesn't respond to @selector(lockCaptureOrientationOrientation:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        PlatformDeviceOrientationBox *boxedPlatformDeviceOrientation = GetNullableObjectAtIndex(args, 0);
        PlatformDeviceOrientation arg_orientation = boxedPlatformDeviceOrientation.value;
        FlutterError *error;
        [api lockCaptureOrientationOrientation:arg_orientation error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Unlocks the orientation for the camera with the given ID.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.unlockCaptureOrientation", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(unlockCaptureOrientationWithError:)], @"CameraApi api (%@) doesn't respond to @selector(unlockCaptureOrientationWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api unlockCaptureOrientationWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Takes a picture on the camera with the given ID and returns a path to the
  /// resulting file.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.takePicture", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(takePictureWithCompletion:)], @"CameraApi api (%@) doesn't respond to @selector(takePictureWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api takePictureWithCompletion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Starts recording a video on the camera with the given ID.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.startVideoRecording", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(startVideoRecordingEnableStream:error:)], @"CameraApi api (%@) doesn't respond to @selector(startVideoRecordingEnableStream:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        BOOL arg_enableStream = [GetNullableObjectAtIndex(args, 0) boolValue];
        FlutterError *error;
        [api startVideoRecordingEnableStream:arg_enableStream error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Ends video recording on the camera with the given ID and returns the path
  /// to the resulting file.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.stopVideoRecording", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(stopVideoRecordingWithError:)], @"CameraApi api (%@) doesn't respond to @selector(stopVideoRecordingWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSString *output = [api stopVideoRecordingWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Pauses video recording on the camera with the given ID.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.pauseVideoRecording", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(pauseVideoRecordingWithError:)], @"CameraApi api (%@) doesn't respond to @selector(pauseVideoRecordingWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api pauseVideoRecordingWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Resumes previously paused video recording on the camera with the given ID.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.resumeVideoRecording", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(resumeVideoRecordingWithError:)], @"CameraApi api (%@) doesn't respond to @selector(resumeVideoRecordingWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api resumeVideoRecordingWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Begins streaming frames from the camera.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.startImageStream", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(startImageStreamWithError:)], @"CameraApi api (%@) doesn't respond to @selector(startImageStreamWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api startImageStreamWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Stops streaming frames from the camera.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.stopImageStream", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(stopImageStreamWithError:)], @"CameraApi api (%@) doesn't respond to @selector(stopImageStreamWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api stopImageStreamWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the flash mode of the camera with the given ID.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.setFlashMode", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setFlashModeFlashMode:completion:)], @"CameraApi api (%@) doesn't respond to @selector(setFlashModeFlashMode:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        PlatformFlashModeBox *boxedPlatformFlashMode = GetNullableObjectAtIndex(args, 0);
        PlatformFlashMode arg_flashMode = boxedPlatformFlashMode.value;
        [api setFlashModeFlashMode:arg_flashMode completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the exposure mode of the camera with the given ID.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.setExposureMode", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setExposureModeExposureMode:completion:)], @"CameraApi api (%@) doesn't respond to @selector(setExposureModeExposureMode:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        PlatformExposureModeBox *boxedPlatformExposureMode = GetNullableObjectAtIndex(args, 0);
        PlatformExposureMode arg_exposureMode = boxedPlatformExposureMode.value;
        [api setExposureModeExposureMode:arg_exposureMode completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the exposure point of the camera with the given ID.
  ///
  /// A null value resets to the default exposure point.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.setExposurePoint", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setExposurePointPoint:completion:)], @"CameraApi api (%@) doesn't respond to @selector(setExposurePointPoint:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        PlatformPoint *arg_point = GetNullableObjectAtIndex(args, 0);
        [api setExposurePointPoint:arg_point completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.setFocusPoint", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setFocusPointPoint:completion:)], @"CameraApi api (%@) doesn't respond to @selector(setFocusPointPoint:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        PlatformPoint *arg_point = GetNullableObjectAtIndex(args, 0);
        [api setFocusPointPoint:arg_point completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the minimum exposure offset of the camera with the given ID.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.getMinExposureOffset", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getMinExposureOffsetWithError:)], @"CameraApi api (%@) doesn't respond to @selector(getMinExposureOffsetWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api getMinExposureOffsetWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the maximum exposure offset of the camera with the given ID.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.getMaxExposureOffset", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getMaxExposureOffsetWithError:)], @"CameraApi api (%@) doesn't respond to @selector(getMaxExposureOffsetWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api getMaxExposureOffsetWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the exposure step size of the camera with the given ID.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.getExposureOffsetStepSize", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getExposureOffsetStepSizeWithError:)], @"CameraApi api (%@) doesn't respond to @selector(getExposureOffsetStepSizeWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api getExposureOffsetStepSizeWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the exposure offset of the camera with the given ID and returns the
  /// actual exposure offset.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.setExposureOffset", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setExposureOffsetOffset:completion:)], @"CameraApi api (%@) doesn't respond to @selector(setExposureOffsetOffset:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        double arg_offset = [GetNullableObjectAtIndex(args, 0) doubleValue];
        [api setExposureOffsetOffset:arg_offset completion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the focus mode of the camera with the given ID.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.setFocusMode", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setFocusModeFocusMode:error:)], @"CameraApi api (%@) doesn't respond to @selector(setFocusModeFocusMode:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        PlatformFocusModeBox *boxedPlatformFocusMode = GetNullableObjectAtIndex(args, 0);
        PlatformFocusMode arg_focusMode = boxedPlatformFocusMode.value;
        FlutterError *error;
        [api setFocusModeFocusMode:arg_focusMode error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the focus point of the camera with the given ID.
  ///
  /// A null value resets to the default focus point.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.setFocusDistance", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setFocusDistanceDistance:completion:)], @"CameraApi api (%@) doesn't respond to @selector(setFocusDistanceDistance:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSNumber *arg_distance = GetNullableObjectAtIndex(args, 0);
        [api setFocusDistanceDistance:arg_distance completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the maximum zoom level of the camera with the given ID.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.getMaxZoomLevel", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getMaxZoomLevelWithError:)], @"CameraApi api (%@) doesn't respond to @selector(getMaxZoomLevelWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api getMaxZoomLevelWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the minimum zoom level of the camera with the given ID.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.getMinZoomLevel", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getMinZoomLevelWithError:)], @"CameraApi api (%@) doesn't respond to @selector(getMinZoomLevelWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api getMinZoomLevelWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the zoom level of the camera with the given ID.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.setZoomLevel", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setZoomLevelZoom:completion:)], @"CameraApi api (%@) doesn't respond to @selector(setZoomLevelZoom:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        double arg_zoom = [GetNullableObjectAtIndex(args, 0) doubleValue];
        [api setZoomLevelZoom:arg_zoom completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Pauses streaming of preview frames.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.pausePreview", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(pausePreviewWithError:)], @"CameraApi api (%@) doesn't respond to @selector(pausePreviewWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api pausePreviewWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Resumes previously paused streaming of preview frames.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.resumePreview", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(resumePreviewWithError:)], @"CameraApi api (%@) doesn't respond to @selector(resumePreviewWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api resumePreviewWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Changes the camera while recording video.
  ///
  /// This should be called only while video recording is active.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:[NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraApi.setDescriptionWhileRecording", messageChannelSuffix]
        binaryMessenger:binaryMessenger
        codec:nullGetMessagesCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setDescriptionWhileRecordingDescription:error:)], @"CameraApi api (%@) doesn't respond to @selector(setDescriptionWhileRecordingDescription:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray<id> *args = message;
        NSString *arg_description = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setDescriptionWhileRecordingDescription:arg_description error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface CameraGlobalEventApi ()
@property(nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@property(nonatomic, strong) NSString *messageChannelSuffix;
@end

@implementation CameraGlobalEventApi

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  return [self initWithBinaryMessenger:binaryMessenger messageChannelSuffix:@""];
}
- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger messageChannelSuffix:(nullable NSString*)messageChannelSuffix{
  self = [self init];
  if (self) {
    _binaryMessenger = binaryMessenger;
    _messageChannelSuffix = [messageChannelSuffix length] == 0 ? @"" : [NSString stringWithFormat: @".%@", messageChannelSuffix];
  }
  return self;
}
- (void)deviceOrientationChangedOrientation:(PlatformDeviceOrientation)arg_orientation completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraGlobalEventApi.deviceOrientationChanged", _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:channelName
      binaryMessenger:self.binaryMessenger
      codec:nullGetMessagesCodec()];
  [channel sendMessage:@[[[PlatformDeviceOrientationBox alloc] initWithValue:arg_orientation]] reply:^(NSArray<id> *reply) {
    if (reply != nil) {
      if (reply.count > 1) {
        completion([FlutterError errorWithCode:reply[0] message:reply[1] details:reply[2]]);
      } else {
        completion(nil);
      }
    } else {
      completion(createConnectionError(channelName));
    } 
  }];
}
@end

@interface CameraEventApi ()
@property(nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@property(nonatomic, strong) NSString *messageChannelSuffix;
@end

@implementation CameraEventApi

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  return [self initWithBinaryMessenger:binaryMessenger messageChannelSuffix:@""];
}
- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger messageChannelSuffix:(nullable NSString*)messageChannelSuffix{
  self = [self init];
  if (self) {
    _binaryMessenger = binaryMessenger;
    _messageChannelSuffix = [messageChannelSuffix length] == 0 ? @"" : [NSString stringWithFormat: @".%@", messageChannelSuffix];
  }
  return self;
}
- (void)initializedInitialState:(PlatformCameraState *)arg_initialState completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraEventApi.initialized", _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:channelName
      binaryMessenger:self.binaryMessenger
      codec:nullGetMessagesCodec()];
  [channel sendMessage:@[arg_initialState ?: [NSNull null]] reply:^(NSArray<id> *reply) {
    if (reply != nil) {
      if (reply.count > 1) {
        completion([FlutterError errorWithCode:reply[0] message:reply[1] details:reply[2]]);
      } else {
        completion(nil);
      }
    } else {
      completion(createConnectionError(channelName));
    } 
  }];
}
- (void)errorMessage:(NSString *)arg_message completion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraEventApi.error", _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:channelName
      binaryMessenger:self.binaryMessenger
      codec:nullGetMessagesCodec()];
  [channel sendMessage:@[arg_message ?: [NSNull null]] reply:^(NSArray<id> *reply) {
    if (reply != nil) {
      if (reply.count > 1) {
        completion([FlutterError errorWithCode:reply[0] message:reply[1] details:reply[2]]);
      } else {
        completion(nil);
      }
    } else {
      completion(createConnectionError(channelName));
    } 
  }];
}
- (void)closedWithCompletion:(void (^)(FlutterError *_Nullable))completion {
  NSString *channelName = [NSString stringWithFormat:@"%@%@", @"dev.flutter.pigeon.camera_android.CameraEventApi.closed", _messageChannelSuffix];
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:channelName
      binaryMessenger:self.binaryMessenger
      codec:nullGetMessagesCodec()];
  [channel sendMessage:nil reply:^(NSArray<id> *reply) {
    if (reply != nil) {
      if (reply.count > 1) {
        completion([FlutterError errorWithCode:reply[0] message:reply[1] details:reply[2]]);
      } else {
        completion(nil);
      }
    } else {
      completion(createConnectionError(channelName));
    } 
  }];
}
@end

